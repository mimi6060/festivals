package security

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/mimi6060/festivals/backend/internal/pkg/errors"
	"github.com/rs/zerolog/log"
)

// NotificationSender interface for sending push notifications
type NotificationSender interface {
	SendSecurityAlertNotification(ctx context.Context, festivalID uuid.UUID, alert *Alert) error
}

// Service handles security alert business logic
type Service struct {
	repo         Repository
	notifier     NotificationSender
	sosRateLimit time.Duration
}

// ServiceConfig holds configuration for the security service
type ServiceConfig struct {
	SOSRateLimitMinutes int
}

// NewService creates a new security service
func NewService(repo Repository, notifier NotificationSender, cfg ServiceConfig) *Service {
	rateLimitDuration := 5 * time.Minute
	if cfg.SOSRateLimitMinutes > 0 {
		rateLimitDuration = time.Duration(cfg.SOSRateLimitMinutes) * time.Minute
	}

	return &Service{
		repo:         repo,
		notifier:     notifier,
		sosRateLimit: rateLimitDuration,
	}
}

// CreateSOSAlert creates an SOS alert from a user
func (s *Service) CreateSOSAlert(ctx context.Context, festivalID, userID uuid.UUID, req SOSRequest) (*Alert, error) {
	// Check rate limiting
	since := time.Now().Add(-s.sosRateLimit)
	recentSOS, err := s.repo.GetRecentSOSByUser(ctx, userID, since)
	if err != nil {
		return nil, fmt.Errorf("failed to check rate limit: %w", err)
	}

	if recentSOS != nil {
		timeSince := time.Since(recentSOS.CreatedAt)
		remainingTime := s.sosRateLimit - timeSince
		return nil, errors.New("RATE_LIMITED", fmt.Sprintf("SOS rate limit exceeded. Please wait %d seconds before sending another SOS.", int(remainingTime.Seconds())))
	}

	// Create the SOS alert
	alert := &Alert{
		ID:           uuid.New(),
		FestivalID:   festivalID,
		UserID:       &userID,
		Type:         AlertTypeSOS,
		Severity:     AlertSeverityHigh,
		Status:       AlertStatusPending,
		Title:        "SOS Alert",
		Description:  req.Message,
		Location:     req.Location,
		ContactPhone: req.ContactPhone,
		Metadata: AlertMetadata{
			AutoGenerated: false,
		},
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	if req.Message == "" {
		alert.Description = "User triggered SOS alert - immediate assistance needed"
	}

	if err := s.repo.CreateAlert(ctx, alert); err != nil {
		return nil, fmt.Errorf("failed to create SOS alert: %w", err)
	}

	// Send notification to security team
	if s.notifier != nil {
		go func() {
			if err := s.notifier.SendSecurityAlertNotification(context.Background(), festivalID, alert); err != nil {
				log.Error().Err(err).Str("alertId", alert.ID.String()).Msg("Failed to send security notification")
			}
		}()
	}

	log.Info().
		Str("alertId", alert.ID.String()).
		Str("userId", userID.String()).
		Float64("lat", req.Location.Latitude).
		Float64("lng", req.Location.Longitude).
		Msg("SOS alert created")

	return alert, nil
}

// CreateSecurityAlert creates a security alert (typically from staff or automatic detection)
func (s *Service) CreateSecurityAlert(ctx context.Context, festivalID uuid.UUID, creatorID *uuid.UUID, req CreateAlertRequest) (*Alert, error) {
	// Set default severity if not provided
	severity := req.Severity
	if severity == "" {
		severity = AlertSeverityMedium
	}

	alert := &Alert{
		ID:           uuid.New(),
		FestivalID:   festivalID,
		UserID:       creatorID,
		Type:         req.Type,
		Severity:     severity,
		Status:       AlertStatusPending,
		Title:        req.Title,
		Description:  req.Description,
		Location:     req.Location,
		ContactPhone: req.ContactPhone,
		Metadata:     req.Metadata,
		CreatedAt:    time.Now(),
		UpdatedAt:    time.Now(),
	}

	if err := s.repo.CreateAlert(ctx, alert); err != nil {
		return nil, fmt.Errorf("failed to create security alert: %w", err)
	}

	// Send notification for high priority alerts
	if s.notifier != nil && (severity == AlertSeverityCritical || severity == AlertSeverityHigh) {
		go func() {
			if err := s.notifier.SendSecurityAlertNotification(context.Background(), festivalID, alert); err != nil {
				log.Error().Err(err).Str("alertId", alert.ID.String()).Msg("Failed to send security notification")
			}
		}()
	}

	log.Info().
		Str("alertId", alert.ID.String()).
		Str("type", string(req.Type)).
		Str("severity", string(severity)).
		Msg("Security alert created")

	return alert, nil
}

// GetActiveAlerts returns all active alerts for a festival
func (s *Service) GetActiveAlerts(ctx context.Context, festivalID uuid.UUID) ([]Alert, error) {
	alerts, err := s.repo.GetActiveAlerts(ctx, festivalID)
	if err != nil {
		return nil, err
	}
	return alerts, nil
}

// GetAlertsByFestival returns alerts with filters and pagination
func (s *Service) GetAlertsByFestival(ctx context.Context, festivalID uuid.UUID, filters AlertFilters, page, perPage int) ([]Alert, int64, error) {
	if page < 1 {
		page = 1
	}
	if perPage < 1 || perPage > 100 {
		perPage = 20
	}

	offset := (page - 1) * perPage
	return s.repo.GetAlertsByFestival(ctx, festivalID, filters, offset, perPage)
}

// GetAlertByID returns a specific alert
func (s *Service) GetAlertByID(ctx context.Context, id uuid.UUID) (*Alert, error) {
	alert, err := s.repo.GetAlertByID(ctx, id)
	if err != nil {
		return nil, err
	}
	if alert == nil {
		return nil, errors.ErrNotFound
	}
	return alert, nil
}

// AcknowledgeAlert marks an alert as acknowledged
func (s *Service) AcknowledgeAlert(ctx context.Context, alertID, acknowledgedBy uuid.UUID) (*Alert, error) {
	alert, err := s.repo.GetAlertByID(ctx, alertID)
	if err != nil {
		return nil, err
	}
	if alert == nil {
		return nil, errors.ErrNotFound
	}

	if alert.Status != AlertStatusPending {
		return nil, errors.New("INVALID_STATUS", "Alert can only be acknowledged when pending")
	}

	now := time.Now()
	alert.Status = AlertStatusAcknowledged
	alert.AcknowledgedAt = &now
	alert.AcknowledgedBy = &acknowledgedBy
	alert.UpdatedAt = now

	if err := s.repo.UpdateAlert(ctx, alert); err != nil {
		return nil, fmt.Errorf("failed to acknowledge alert: %w", err)
	}

	log.Info().
		Str("alertId", alertID.String()).
		Str("acknowledgedBy", acknowledgedBy.String()).
		Msg("Alert acknowledged")

	return alert, nil
}

// AssignAlert assigns an alert to a staff member
func (s *Service) AssignAlert(ctx context.Context, alertID, assignedTo, assignedBy uuid.UUID) (*Alert, error) {
	alert, err := s.repo.GetAlertByID(ctx, alertID)
	if err != nil {
		return nil, err
	}
	if alert == nil {
		return nil, errors.ErrNotFound
	}

	if alert.Status == AlertStatusResolved || alert.Status == AlertStatusCancelled {
		return nil, errors.New("INVALID_STATUS", "Cannot assign a resolved or cancelled alert")
	}

	now := time.Now()
	alert.AssignedTo = &assignedTo
	alert.Status = AlertStatusInProgress
	alert.UpdatedAt = now

	// Also acknowledge if not yet acknowledged
	if alert.AcknowledgedAt == nil {
		alert.AcknowledgedAt = &now
		alert.AcknowledgedBy = &assignedBy
	}

	if err := s.repo.UpdateAlert(ctx, alert); err != nil {
		return nil, fmt.Errorf("failed to assign alert: %w", err)
	}

	log.Info().
		Str("alertId", alertID.String()).
		Str("assignedTo", assignedTo.String()).
		Msg("Alert assigned")

	return alert, nil
}

// ResolveAlert marks an alert as resolved
func (s *Service) ResolveAlert(ctx context.Context, alertID, resolvedBy uuid.UUID, resolution string) (*Alert, error) {
	alert, err := s.repo.GetAlertByID(ctx, alertID)
	if err != nil {
		return nil, err
	}
	if alert == nil {
		return nil, errors.ErrNotFound
	}

	if alert.Status == AlertStatusResolved || alert.Status == AlertStatusCancelled {
		return nil, errors.New("INVALID_STATUS", "Alert is already resolved or cancelled")
	}

	now := time.Now()
	alert.Status = AlertStatusResolved
	alert.ResolvedAt = &now
	alert.ResolvedBy = &resolvedBy
	alert.Resolution = resolution
	alert.UpdatedAt = now

	if err := s.repo.UpdateAlert(ctx, alert); err != nil {
		return nil, fmt.Errorf("failed to resolve alert: %w", err)
	}

	log.Info().
		Str("alertId", alertID.String()).
		Str("resolvedBy", resolvedBy.String()).
		Str("resolution", resolution).
		Msg("Alert resolved")

	return alert, nil
}

// CancelAlert marks an alert as cancelled (e.g., false alarm)
func (s *Service) CancelAlert(ctx context.Context, alertID, cancelledBy uuid.UUID, reason string) (*Alert, error) {
	alert, err := s.repo.GetAlertByID(ctx, alertID)
	if err != nil {
		return nil, err
	}
	if alert == nil {
		return nil, errors.ErrNotFound
	}

	if alert.Status == AlertStatusResolved || alert.Status == AlertStatusCancelled {
		return nil, errors.New("INVALID_STATUS", "Alert is already resolved or cancelled")
	}

	now := time.Now()
	alert.Status = AlertStatusCancelled
	alert.ResolvedAt = &now
	alert.ResolvedBy = &cancelledBy
	alert.Resolution = fmt.Sprintf("Cancelled: %s", reason)
	alert.UpdatedAt = now

	if err := s.repo.UpdateAlert(ctx, alert); err != nil {
		return nil, fmt.Errorf("failed to cancel alert: %w", err)
	}

	log.Info().
		Str("alertId", alertID.String()).
		Str("cancelledBy", cancelledBy.String()).
		Str("reason", reason).
		Msg("Alert cancelled")

	return alert, nil
}

// UpdateAlert updates an alert's details
func (s *Service) UpdateAlert(ctx context.Context, alertID uuid.UUID, req UpdateAlertRequest) (*Alert, error) {
	alert, err := s.repo.GetAlertByID(ctx, alertID)
	if err != nil {
		return nil, err
	}
	if alert == nil {
		return nil, errors.ErrNotFound
	}

	if req.Status != nil {
		alert.Status = *req.Status
	}
	if req.Severity != nil {
		alert.Severity = *req.Severity
	}
	if req.AssignedTo != nil {
		alert.AssignedTo = req.AssignedTo
	}
	if req.Description != nil {
		alert.Description = *req.Description
	}
	if req.Resolution != nil {
		alert.Resolution = *req.Resolution
	}

	alert.UpdatedAt = time.Now()

	if err := s.repo.UpdateAlert(ctx, alert); err != nil {
		return nil, fmt.Errorf("failed to update alert: %w", err)
	}

	return alert, nil
}

// GetAlertStats returns statistics for a festival
func (s *Service) GetAlertStats(ctx context.Context, festivalID uuid.UUID) (*AlertStats, error) {
	return s.repo.GetAlertStats(ctx, festivalID)
}

// GetUserAlerts returns alerts created by a specific user
func (s *Service) GetUserAlerts(ctx context.Context, userID uuid.UUID, page, perPage int) ([]Alert, int64, error) {
	if page < 1 {
		page = 1
	}
	if perPage < 1 || perPage > 100 {
		perPage = 20
	}

	offset := (page - 1) * perPage
	return s.repo.GetAlertsByUser(ctx, userID, offset, perPage)
}

// Security zone methods

// CreateZone creates a new security zone
func (s *Service) CreateZone(ctx context.Context, festivalID uuid.UUID, req CreateZoneRequest) (*SecurityZone, error) {
	zone := &SecurityZone{
		ID:          uuid.New(),
		FestivalID:  festivalID,
		Name:        req.Name,
		Description: req.Description,
		Type:        req.Type,
		Coordinates: req.Coordinates,
		Capacity:    req.Capacity,
		AlertLevel:  AlertSeverityLow,
		IsActive:    true,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	if err := s.repo.CreateZone(ctx, zone); err != nil {
		return nil, fmt.Errorf("failed to create zone: %w", err)
	}

	log.Info().
		Str("zoneId", zone.ID.String()).
		Str("name", zone.Name).
		Msg("Security zone created")

	return zone, nil
}

// GetZonesByFestival returns all security zones for a festival
func (s *Service) GetZonesByFestival(ctx context.Context, festivalID uuid.UUID) ([]SecurityZone, error) {
	return s.repo.GetZonesByFestival(ctx, festivalID)
}

// GetZoneByID returns a specific zone
func (s *Service) GetZoneByID(ctx context.Context, id uuid.UUID) (*SecurityZone, error) {
	zone, err := s.repo.GetZoneByID(ctx, id)
	if err != nil {
		return nil, err
	}
	if zone == nil {
		return nil, errors.ErrNotFound
	}
	return zone, nil
}

// UpdateZone updates a security zone
func (s *Service) UpdateZone(ctx context.Context, id uuid.UUID, req UpdateZoneRequest) (*SecurityZone, error) {
	zone, err := s.repo.GetZoneByID(ctx, id)
	if err != nil {
		return nil, err
	}
	if zone == nil {
		return nil, errors.ErrNotFound
	}

	if req.Name != nil {
		zone.Name = *req.Name
	}
	if req.Description != nil {
		zone.Description = *req.Description
	}
	if req.Type != nil {
		zone.Type = *req.Type
	}
	if req.Coordinates != nil {
		zone.Coordinates = req.Coordinates
	}
	if req.Capacity != nil {
		zone.Capacity = *req.Capacity
	}
	if req.AlertLevel != nil {
		zone.AlertLevel = *req.AlertLevel
	}
	if req.IsActive != nil {
		zone.IsActive = *req.IsActive
	}

	zone.UpdatedAt = time.Now()

	if err := s.repo.UpdateZone(ctx, zone); err != nil {
		return nil, fmt.Errorf("failed to update zone: %w", err)
	}

	return zone, nil
}

// DeleteZone removes a security zone
func (s *Service) DeleteZone(ctx context.Context, id uuid.UUID) error {
	zone, err := s.repo.GetZoneByID(ctx, id)
	if err != nil {
		return err
	}
	if zone == nil {
		return errors.ErrNotFound
	}

	return s.repo.DeleteZone(ctx, id)
}
